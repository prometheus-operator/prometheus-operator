// Copyright The prometheus-operator Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// AlertmanagerSpecApplyConfiguration represents a declarative configuration of the AlertmanagerSpec type for use
// with apply.
//
// AlertmanagerSpec is a specification of the desired behavior of the Alertmanager cluster. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type AlertmanagerSpecApplyConfiguration struct {
	// podMetadata defines labels and annotations which are propagated to the Alertmanager pods.
	//
	// The following items are reserved and cannot be overridden:
	// * "alertmanager" label, set to the name of the Alertmanager instance.
	// * "app.kubernetes.io/instance" label, set to the name of the Alertmanager instance.
	// * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
	// * "app.kubernetes.io/name" label, set to "alertmanager".
	// * "app.kubernetes.io/version" label, set to the Alertmanager version.
	// * "kubectl.kubernetes.io/default-container" annotation, set to "alertmanager".
	PodMetadata *EmbeddedObjectMetadataApplyConfiguration `json:"podMetadata,omitempty"`
	// image if specified has precedence over baseImage, tag and sha
	// combinations. Specifying the version is still necessary to ensure the
	// Prometheus Operator knows what version of Alertmanager is being
	// configured.
	Image *string `json:"image,omitempty"`
	// imagePullPolicy for the 'alertmanager', 'init-config-reloader' and 'config-reloader' containers.
	// See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
	ImagePullPolicy *corev1.PullPolicy `json:"imagePullPolicy,omitempty"`
	// version the cluster should be on.
	Version *string `json:"version,omitempty"`
	// tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
	// Version is ignored if Tag is set.
	// Deprecated: use 'image' instead. The image tag can be specified as part of the image URL.
	Tag *string `json:"tag,omitempty"`
	// sha of Alertmanager container image to be deployed. Defaults to the value of `version`.
	// Similar to a tag, but the SHA explicitly deploys an immutable container image.
	// Version and Tag are ignored if SHA is set.
	// Deprecated: use 'image' instead. The image digest can be specified as part of the image URL.
	SHA *string `json:"sha,omitempty"`
	// baseImage that is used to deploy pods, without tag.
	// Deprecated: use 'image' instead.
	BaseImage *string `json:"baseImage,omitempty"`
	// imagePullSecrets An optional list of references to secrets in the same namespace
	// to use for pulling prometheus and alertmanager images from registries
	// see https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
	ImagePullSecrets []corev1.LocalObjectReference `json:"imagePullSecrets,omitempty"`
	// secrets is a list of Secrets in the same namespace as the Alertmanager
	// object, which shall be mounted into the Alertmanager Pods.
	// Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
	// The Secrets are mounted into `/etc/alertmanager/secrets/<secret-name>` in the 'alertmanager' container.
	Secrets []string `json:"secrets,omitempty"`
	// configMaps defines a list of ConfigMaps in the same namespace as the Alertmanager
	// object, which shall be mounted into the Alertmanager Pods.
	// Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
	// The ConfigMaps are mounted into `/etc/alertmanager/configmaps/<configmap-name>` in the 'alertmanager' container.
	ConfigMaps []string `json:"configMaps,omitempty"`
	// configSecret defines the name of a Kubernetes Secret in the same namespace as the
	// Alertmanager object, which contains the configuration for this Alertmanager
	// instance. If empty, it defaults to `alertmanager-<alertmanager-name>`.
	//
	// The Alertmanager configuration should be available under the
	// `alertmanager.yaml` key. Additional keys from the original secret are
	// copied to the generated secret and mounted into the
	// `/etc/alertmanager/config` directory in the `alertmanager` container.
	//
	// If either the secret or the `alertmanager.yaml` key is missing, the
	// operator provisions a minimal Alertmanager configuration with one empty
	// receiver (effectively dropping alert notifications).
	ConfigSecret *string `json:"configSecret,omitempty"`
	// logLevel for Alertmanager to be configured with.
	LogLevel *string `json:"logLevel,omitempty"`
	// logFormat for Alertmanager to be configured with.
	LogFormat *string `json:"logFormat,omitempty"`
	// replicas defines the expected size of the alertmanager cluster. The controller will
	// eventually make the size of the running cluster equal to the expected
	// size.
	Replicas *int32 `json:"replicas,omitempty"`
	// retention defines the time duration Alertmanager shall retain data for. Default is '120h',
	// and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
	Retention *monitoringv1.GoDuration `json:"retention,omitempty"`
	// storage defines the definition of how storage will be used by the Alertmanager
	// instances.
	Storage *StorageSpecApplyConfiguration `json:"storage,omitempty"`
	// volumes allows configuration of additional volumes on the output StatefulSet definition.
	// Volumes specified will be appended to other volumes that are generated as a result of
	// StorageSpec objects.
	Volumes []corev1.Volume `json:"volumes,omitempty"`
	// volumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
	// VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
	// that are generated as a result of StorageSpec objects.
	VolumeMounts []corev1.VolumeMount `json:"volumeMounts,omitempty"`
	// persistentVolumeClaimRetentionPolicy controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
	// The default behavior is all PVCs are retained.
	// This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
	// It requires enabling the StatefulSetAutoDeletePVC feature gate.
	PersistentVolumeClaimRetentionPolicy *appsv1.StatefulSetPersistentVolumeClaimRetentionPolicy `json:"persistentVolumeClaimRetentionPolicy,omitempty"`
	// externalUrl defines the URL used to access the Alertmanager web service. This is
	// necessary to generate correct URLs. This is necessary if Alertmanager is not
	// served from root of a DNS name.
	ExternalURL *string `json:"externalUrl,omitempty"`
	// routePrefix Alertmanager registers HTTP handlers for. This is useful,
	// if using ExternalURL and a proxy is rewriting HTTP routes of a request,
	// and the actual ExternalURL is still true, but the server serves requests
	// under a different route prefix. For example for use with `kubectl proxy`.
	RoutePrefix *string `json:"routePrefix,omitempty"`
	// paused if set to true all actions on the underlying managed objects are not
	// going to be performed, except for delete actions.
	Paused *bool `json:"paused,omitempty"`
	// nodeSelector defines which Nodes the Pods are scheduled on.
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`
	// resources defines the resource requests and limits of the Pods.
	Resources *corev1.ResourceRequirements `json:"resources,omitempty"`
	// affinity defines the pod's scheduling constraints.
	Affinity *corev1.Affinity `json:"affinity,omitempty"`
	// tolerations defines the pod's tolerations.
	Tolerations []corev1.Toleration `json:"tolerations,omitempty"`
	// topologySpreadConstraints defines the Pod's topology spread constraints.
	TopologySpreadConstraints []corev1.TopologySpreadConstraint `json:"topologySpreadConstraints,omitempty"`
	// securityContext holds pod-level security attributes and common container settings.
	// This defaults to the default PodSecurityContext.
	SecurityContext *corev1.PodSecurityContext `json:"securityContext,omitempty"`
	// dnsPolicy defines the DNS policy for the pods.
	DNSPolicy *monitoringv1.DNSPolicy `json:"dnsPolicy,omitempty"`
	// dnsConfig defines the DNS configuration for the pods.
	DNSConfig *PodDNSConfigApplyConfiguration `json:"dnsConfig,omitempty"`
	// enableServiceLinks defines whether information about services should be injected into pod's environment variables
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`
	// serviceName defines the service name used by the underlying StatefulSet(s) as the governing service.
	// If defined, the Service  must be created before the Alertmanager resource in the same namespace and it must define a selector that matches the pod labels.
	// If empty, the operator will create and manage a headless service named `alertmanager-operated` for Alertmanager resources.
	// When deploying multiple Alertmanager resources in the same namespace, it is recommended to specify a different value for each.
	// See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id for more details.
	ServiceName *string `json:"serviceName,omitempty"`
	// serviceAccountName is the name of the ServiceAccount to use to run the
	// Prometheus Pods.
	ServiceAccountName *string `json:"serviceAccountName,omitempty"`
	// listenLocal defines the Alertmanager server listen on loopback, so that it
	// does not bind against the Pod IP. Note this is only for the Alertmanager
	// UI, not the gossip communication.
	ListenLocal *bool `json:"listenLocal,omitempty"`
	// podManagementPolicy defines the policy for creating/deleting pods when
	// scaling up and down.
	//
	// Unlike the default StatefulSet behavior, the default policy is
	// `Parallel` to avoid manual intervention in case a pod gets stuck during
	// a rollout.
	//
	// Note that updating this value implies the recreation of the StatefulSet
	// which incurs a service outage.
	PodManagementPolicy *monitoringv1.PodManagementPolicyType `json:"podManagementPolicy,omitempty"`
	// containers allows injecting additional containers. This is meant to
	// allow adding an authentication proxy to an Alertmanager pod.
	// Containers described here modify an operator generated container if they
	// share the same name and modifications are done via a strategic merge
	// patch. The current container names are: `alertmanager` and
	// `config-reloader`. Overriding containers is entirely outside the scope
	// of what the maintainers will support and by doing so, you accept that
	// this behaviour may break at any time without notice.
	Containers []corev1.Container `json:"containers,omitempty"`
	// initContainers allows adding initContainers to the pod definition. Those can be used to e.g.
	// fetch secrets for injection into the Alertmanager configuration from external sources. Any
	// errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// InitContainers described here modify an operator
	// generated init containers if they share the same name and modifications are
	// done via a strategic merge patch. The current init container name is:
	// `init-config-reloader`. Overriding init containers is entirely outside the
	// scope of what the maintainers will support and by doing so, you accept that
	// this behaviour may break at any time without notice.
	InitContainers []corev1.Container `json:"initContainers,omitempty"`
	// priorityClassName assigned to the Pods
	PriorityClassName *string `json:"priorityClassName,omitempty"`
	// additionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
	AdditionalPeers []string `json:"additionalPeers,omitempty"`
	// clusterAdvertiseAddress defines the explicit address to advertise in cluster.
	// Needs to be provided for non RFC1918 [1] (public) addresses.
	// [1] RFC1918: https://tools.ietf.org/html/rfc1918
	ClusterAdvertiseAddress *string `json:"clusterAdvertiseAddress,omitempty"`
	// clusterGossipInterval defines the interval between gossip attempts.
	ClusterGossipInterval *monitoringv1.GoDuration `json:"clusterGossipInterval,omitempty"`
	// clusterLabel defines the identifier that uniquely identifies the Alertmanager cluster.
	// You should only set it when the Alertmanager cluster includes Alertmanager instances which are external to this Alertmanager resource. In practice, the addresses of the external instances are provided via the `.spec.additionalPeers` field.
	ClusterLabel *string `json:"clusterLabel,omitempty"`
	// clusterPushpullInterval defines the interval between pushpull attempts.
	ClusterPushpullInterval *monitoringv1.GoDuration `json:"clusterPushpullInterval,omitempty"`
	// clusterPeerTimeout defines the timeout for cluster peering.
	ClusterPeerTimeout *monitoringv1.GoDuration `json:"clusterPeerTimeout,omitempty"`
	// portName defines the port's name for the pods and governing service.
	// Defaults to `web`.
	PortName *string `json:"portName,omitempty"`
	// forceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
	// Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
	ForceEnableClusterMode *bool `json:"forceEnableClusterMode,omitempty"`
	// alertmanagerConfigSelector defines the selector to be used for to merge and configure Alertmanager with.
	AlertmanagerConfigSelector *metav1.LabelSelectorApplyConfiguration `json:"alertmanagerConfigSelector,omitempty"`
	// alertmanagerConfigNamespaceSelector defines the namespaces to be selected for AlertmanagerConfig discovery. If nil, only
	// check own namespace.
	AlertmanagerConfigNamespaceSelector *metav1.LabelSelectorApplyConfiguration `json:"alertmanagerConfigNamespaceSelector,omitempty"`
	// alertmanagerConfigMatcherStrategy defines how AlertmanagerConfig objects
	// process incoming alerts.
	AlertmanagerConfigMatcherStrategy *AlertmanagerConfigMatcherStrategyApplyConfiguration `json:"alertmanagerConfigMatcherStrategy,omitempty"`
	// minReadySeconds defines the minimum number of seconds for which a newly created pod should be ready
	// without any of its container crashing for it to be considered available.
	//
	// If unset, pods will be considered available as soon as they are ready.
	MinReadySeconds *int32 `json:"minReadySeconds,omitempty"`
	// hostAliases Pods configuration
	HostAliases []HostAliasApplyConfiguration `json:"hostAliases,omitempty"`
	// web defines the web command line flags when starting Alertmanager.
	Web *AlertmanagerWebSpecApplyConfiguration `json:"web,omitempty"`
	// limits defines the limits command line flags when starting Alertmanager.
	Limits *AlertmanagerLimitsSpecApplyConfiguration `json:"limits,omitempty"`
	// dispatchStartDelay defines the delay duration of the aggregation groups' first flush.
	// The delay helps ensuring that all alerts have been resent by the Prometheus instances to Alertmanager after a roll-out.
	//
	// It requires Alertmanager >= 0.30.0.
	DispatchStartDelay *monitoringv1.GoDuration `json:"dispatchStartDelay,omitempty"`
	// clusterTLS defines the mutual TLS configuration for the Alertmanager cluster's gossip protocol.
	//
	// It requires Alertmanager >= 0.24.0.
	ClusterTLS *ClusterTLSConfigApplyConfiguration `json:"clusterTLS,omitempty"`
	// alertmanagerConfiguration defines the configuration of Alertmanager.
	//
	// If defined, it takes precedence over the `configSecret` field.
	//
	// This is an *experimental feature*, it may change in any upcoming release
	// in a breaking way.
	AlertmanagerConfiguration *AlertmanagerConfigurationApplyConfiguration `json:"alertmanagerConfiguration,omitempty"`
	// automountServiceAccountToken defines whether a service account token should be automatically mounted in the pod.
	// If the service account has `automountServiceAccountToken: true`, set the field to `false` to opt out of automounting API credentials.
	AutomountServiceAccountToken *bool `json:"automountServiceAccountToken,omitempty"`
	// enableFeatures defines the Alertmanager's feature flags. By default, no features are enabled.
	// Enabling features which are disabled by default is entirely outside the
	// scope of what the maintainers will support and by doing so, you accept
	// that this behaviour may break at any time without notice.
	//
	// It requires Alertmanager >= 0.27.0.
	EnableFeatures []string `json:"enableFeatures,omitempty"`
	// additionalArgs allows setting additional arguments for the 'Alertmanager' container.
	// It is intended for e.g. activating hidden flags which are not supported by
	// the dedicated configuration options yet. The arguments are passed as-is to the
	// Alertmanager container which may cause issues if they are invalid or not supported
	// by the given Alertmanager version.
	AdditionalArgs []ArgumentApplyConfiguration `json:"additionalArgs,omitempty"`
	// terminationGracePeriodSeconds defines the Optional duration in seconds the pod needs to terminate gracefully.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down) which may lead to data corruption.
	//
	// Defaults to 120 seconds.
	TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty"`
	// hostUsers supports the user space in Kubernetes.
	//
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/user-namespaces/
	//
	// The feature requires at least Kubernetes 1.28 with the `UserNamespacesSupport` feature gate enabled.
	// Starting Kubernetes 1.33, the feature is enabled by default.
	HostUsers *bool `json:"hostUsers,omitempty"`
}

// AlertmanagerSpecApplyConfiguration constructs a declarative configuration of the AlertmanagerSpec type for use with
// apply.
func AlertmanagerSpec() *AlertmanagerSpecApplyConfiguration {
	return &AlertmanagerSpecApplyConfiguration{}
}

// WithPodMetadata sets the PodMetadata field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PodMetadata field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPodMetadata(value *EmbeddedObjectMetadataApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.PodMetadata = value
	return b
}

// WithImage sets the Image field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Image field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithImage(value string) *AlertmanagerSpecApplyConfiguration {
	b.Image = &value
	return b
}

// WithImagePullPolicy sets the ImagePullPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ImagePullPolicy field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithImagePullPolicy(value corev1.PullPolicy) *AlertmanagerSpecApplyConfiguration {
	b.ImagePullPolicy = &value
	return b
}

// WithVersion sets the Version field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Version field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithVersion(value string) *AlertmanagerSpecApplyConfiguration {
	b.Version = &value
	return b
}

// WithTag sets the Tag field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Tag field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithTag(value string) *AlertmanagerSpecApplyConfiguration {
	b.Tag = &value
	return b
}

// WithSHA sets the SHA field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SHA field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithSHA(value string) *AlertmanagerSpecApplyConfiguration {
	b.SHA = &value
	return b
}

// WithBaseImage sets the BaseImage field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the BaseImage field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithBaseImage(value string) *AlertmanagerSpecApplyConfiguration {
	b.BaseImage = &value
	return b
}

// WithImagePullSecrets adds the given value to the ImagePullSecrets field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ImagePullSecrets field.
func (b *AlertmanagerSpecApplyConfiguration) WithImagePullSecrets(values ...corev1.LocalObjectReference) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.ImagePullSecrets = append(b.ImagePullSecrets, values[i])
	}
	return b
}

// WithSecrets adds the given value to the Secrets field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Secrets field.
func (b *AlertmanagerSpecApplyConfiguration) WithSecrets(values ...string) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.Secrets = append(b.Secrets, values[i])
	}
	return b
}

// WithConfigMaps adds the given value to the ConfigMaps field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ConfigMaps field.
func (b *AlertmanagerSpecApplyConfiguration) WithConfigMaps(values ...string) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.ConfigMaps = append(b.ConfigMaps, values[i])
	}
	return b
}

// WithConfigSecret sets the ConfigSecret field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ConfigSecret field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithConfigSecret(value string) *AlertmanagerSpecApplyConfiguration {
	b.ConfigSecret = &value
	return b
}

// WithLogLevel sets the LogLevel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LogLevel field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithLogLevel(value string) *AlertmanagerSpecApplyConfiguration {
	b.LogLevel = &value
	return b
}

// WithLogFormat sets the LogFormat field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LogFormat field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithLogFormat(value string) *AlertmanagerSpecApplyConfiguration {
	b.LogFormat = &value
	return b
}

// WithReplicas sets the Replicas field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Replicas field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithReplicas(value int32) *AlertmanagerSpecApplyConfiguration {
	b.Replicas = &value
	return b
}

// WithRetention sets the Retention field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Retention field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithRetention(value monitoringv1.GoDuration) *AlertmanagerSpecApplyConfiguration {
	b.Retention = &value
	return b
}

// WithStorage sets the Storage field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Storage field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithStorage(value *StorageSpecApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.Storage = value
	return b
}

// WithVolumes adds the given value to the Volumes field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Volumes field.
func (b *AlertmanagerSpecApplyConfiguration) WithVolumes(values ...corev1.Volume) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.Volumes = append(b.Volumes, values[i])
	}
	return b
}

// WithVolumeMounts adds the given value to the VolumeMounts field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the VolumeMounts field.
func (b *AlertmanagerSpecApplyConfiguration) WithVolumeMounts(values ...corev1.VolumeMount) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.VolumeMounts = append(b.VolumeMounts, values[i])
	}
	return b
}

// WithPersistentVolumeClaimRetentionPolicy sets the PersistentVolumeClaimRetentionPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PersistentVolumeClaimRetentionPolicy field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPersistentVolumeClaimRetentionPolicy(value appsv1.StatefulSetPersistentVolumeClaimRetentionPolicy) *AlertmanagerSpecApplyConfiguration {
	b.PersistentVolumeClaimRetentionPolicy = &value
	return b
}

// WithExternalURL sets the ExternalURL field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExternalURL field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithExternalURL(value string) *AlertmanagerSpecApplyConfiguration {
	b.ExternalURL = &value
	return b
}

// WithRoutePrefix sets the RoutePrefix field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RoutePrefix field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithRoutePrefix(value string) *AlertmanagerSpecApplyConfiguration {
	b.RoutePrefix = &value
	return b
}

// WithPaused sets the Paused field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Paused field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPaused(value bool) *AlertmanagerSpecApplyConfiguration {
	b.Paused = &value
	return b
}

// WithNodeSelector puts the entries into the NodeSelector field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the NodeSelector field,
// overwriting an existing map entries in NodeSelector field with the same key.
func (b *AlertmanagerSpecApplyConfiguration) WithNodeSelector(entries map[string]string) *AlertmanagerSpecApplyConfiguration {
	if b.NodeSelector == nil && len(entries) > 0 {
		b.NodeSelector = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.NodeSelector[k] = v
	}
	return b
}

// WithResources sets the Resources field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Resources field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithResources(value corev1.ResourceRequirements) *AlertmanagerSpecApplyConfiguration {
	b.Resources = &value
	return b
}

// WithAffinity sets the Affinity field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Affinity field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAffinity(value corev1.Affinity) *AlertmanagerSpecApplyConfiguration {
	b.Affinity = &value
	return b
}

// WithTolerations adds the given value to the Tolerations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Tolerations field.
func (b *AlertmanagerSpecApplyConfiguration) WithTolerations(values ...corev1.Toleration) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.Tolerations = append(b.Tolerations, values[i])
	}
	return b
}

// WithTopologySpreadConstraints adds the given value to the TopologySpreadConstraints field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the TopologySpreadConstraints field.
func (b *AlertmanagerSpecApplyConfiguration) WithTopologySpreadConstraints(values ...corev1.TopologySpreadConstraint) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.TopologySpreadConstraints = append(b.TopologySpreadConstraints, values[i])
	}
	return b
}

// WithSecurityContext sets the SecurityContext field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SecurityContext field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithSecurityContext(value corev1.PodSecurityContext) *AlertmanagerSpecApplyConfiguration {
	b.SecurityContext = &value
	return b
}

// WithDNSPolicy sets the DNSPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DNSPolicy field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithDNSPolicy(value monitoringv1.DNSPolicy) *AlertmanagerSpecApplyConfiguration {
	b.DNSPolicy = &value
	return b
}

// WithDNSConfig sets the DNSConfig field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DNSConfig field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithDNSConfig(value *PodDNSConfigApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.DNSConfig = value
	return b
}

// WithEnableServiceLinks sets the EnableServiceLinks field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the EnableServiceLinks field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithEnableServiceLinks(value bool) *AlertmanagerSpecApplyConfiguration {
	b.EnableServiceLinks = &value
	return b
}

// WithServiceName sets the ServiceName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ServiceName field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithServiceName(value string) *AlertmanagerSpecApplyConfiguration {
	b.ServiceName = &value
	return b
}

// WithServiceAccountName sets the ServiceAccountName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ServiceAccountName field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithServiceAccountName(value string) *AlertmanagerSpecApplyConfiguration {
	b.ServiceAccountName = &value
	return b
}

// WithListenLocal sets the ListenLocal field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ListenLocal field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithListenLocal(value bool) *AlertmanagerSpecApplyConfiguration {
	b.ListenLocal = &value
	return b
}

// WithPodManagementPolicy sets the PodManagementPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PodManagementPolicy field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPodManagementPolicy(value monitoringv1.PodManagementPolicyType) *AlertmanagerSpecApplyConfiguration {
	b.PodManagementPolicy = &value
	return b
}

// WithContainers adds the given value to the Containers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Containers field.
func (b *AlertmanagerSpecApplyConfiguration) WithContainers(values ...corev1.Container) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.Containers = append(b.Containers, values[i])
	}
	return b
}

// WithInitContainers adds the given value to the InitContainers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the InitContainers field.
func (b *AlertmanagerSpecApplyConfiguration) WithInitContainers(values ...corev1.Container) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.InitContainers = append(b.InitContainers, values[i])
	}
	return b
}

// WithPriorityClassName sets the PriorityClassName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PriorityClassName field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPriorityClassName(value string) *AlertmanagerSpecApplyConfiguration {
	b.PriorityClassName = &value
	return b
}

// WithAdditionalPeers adds the given value to the AdditionalPeers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AdditionalPeers field.
func (b *AlertmanagerSpecApplyConfiguration) WithAdditionalPeers(values ...string) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.AdditionalPeers = append(b.AdditionalPeers, values[i])
	}
	return b
}

// WithClusterAdvertiseAddress sets the ClusterAdvertiseAddress field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterAdvertiseAddress field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterAdvertiseAddress(value string) *AlertmanagerSpecApplyConfiguration {
	b.ClusterAdvertiseAddress = &value
	return b
}

// WithClusterGossipInterval sets the ClusterGossipInterval field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterGossipInterval field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterGossipInterval(value monitoringv1.GoDuration) *AlertmanagerSpecApplyConfiguration {
	b.ClusterGossipInterval = &value
	return b
}

// WithClusterLabel sets the ClusterLabel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterLabel field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterLabel(value string) *AlertmanagerSpecApplyConfiguration {
	b.ClusterLabel = &value
	return b
}

// WithClusterPushpullInterval sets the ClusterPushpullInterval field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterPushpullInterval field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterPushpullInterval(value monitoringv1.GoDuration) *AlertmanagerSpecApplyConfiguration {
	b.ClusterPushpullInterval = &value
	return b
}

// WithClusterPeerTimeout sets the ClusterPeerTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterPeerTimeout field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterPeerTimeout(value monitoringv1.GoDuration) *AlertmanagerSpecApplyConfiguration {
	b.ClusterPeerTimeout = &value
	return b
}

// WithPortName sets the PortName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PortName field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithPortName(value string) *AlertmanagerSpecApplyConfiguration {
	b.PortName = &value
	return b
}

// WithForceEnableClusterMode sets the ForceEnableClusterMode field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ForceEnableClusterMode field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithForceEnableClusterMode(value bool) *AlertmanagerSpecApplyConfiguration {
	b.ForceEnableClusterMode = &value
	return b
}

// WithAlertmanagerConfigSelector sets the AlertmanagerConfigSelector field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AlertmanagerConfigSelector field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAlertmanagerConfigSelector(value *metav1.LabelSelectorApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.AlertmanagerConfigSelector = value
	return b
}

// WithAlertmanagerConfigNamespaceSelector sets the AlertmanagerConfigNamespaceSelector field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AlertmanagerConfigNamespaceSelector field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAlertmanagerConfigNamespaceSelector(value *metav1.LabelSelectorApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.AlertmanagerConfigNamespaceSelector = value
	return b
}

// WithAlertmanagerConfigMatcherStrategy sets the AlertmanagerConfigMatcherStrategy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AlertmanagerConfigMatcherStrategy field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAlertmanagerConfigMatcherStrategy(value *AlertmanagerConfigMatcherStrategyApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.AlertmanagerConfigMatcherStrategy = value
	return b
}

// WithMinReadySeconds sets the MinReadySeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MinReadySeconds field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithMinReadySeconds(value int32) *AlertmanagerSpecApplyConfiguration {
	b.MinReadySeconds = &value
	return b
}

// WithHostAliases adds the given value to the HostAliases field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the HostAliases field.
func (b *AlertmanagerSpecApplyConfiguration) WithHostAliases(values ...*HostAliasApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithHostAliases")
		}
		b.HostAliases = append(b.HostAliases, *values[i])
	}
	return b
}

// WithWeb sets the Web field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Web field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithWeb(value *AlertmanagerWebSpecApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.Web = value
	return b
}

// WithLimits sets the Limits field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Limits field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithLimits(value *AlertmanagerLimitsSpecApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.Limits = value
	return b
}

// WithDispatchStartDelay sets the DispatchStartDelay field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DispatchStartDelay field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithDispatchStartDelay(value monitoringv1.GoDuration) *AlertmanagerSpecApplyConfiguration {
	b.DispatchStartDelay = &value
	return b
}

// WithClusterTLS sets the ClusterTLS field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterTLS field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithClusterTLS(value *ClusterTLSConfigApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.ClusterTLS = value
	return b
}

// WithAlertmanagerConfiguration sets the AlertmanagerConfiguration field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AlertmanagerConfiguration field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAlertmanagerConfiguration(value *AlertmanagerConfigurationApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	b.AlertmanagerConfiguration = value
	return b
}

// WithAutomountServiceAccountToken sets the AutomountServiceAccountToken field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AutomountServiceAccountToken field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithAutomountServiceAccountToken(value bool) *AlertmanagerSpecApplyConfiguration {
	b.AutomountServiceAccountToken = &value
	return b
}

// WithEnableFeatures adds the given value to the EnableFeatures field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the EnableFeatures field.
func (b *AlertmanagerSpecApplyConfiguration) WithEnableFeatures(values ...string) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		b.EnableFeatures = append(b.EnableFeatures, values[i])
	}
	return b
}

// WithAdditionalArgs adds the given value to the AdditionalArgs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AdditionalArgs field.
func (b *AlertmanagerSpecApplyConfiguration) WithAdditionalArgs(values ...*ArgumentApplyConfiguration) *AlertmanagerSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAdditionalArgs")
		}
		b.AdditionalArgs = append(b.AdditionalArgs, *values[i])
	}
	return b
}

// WithTerminationGracePeriodSeconds sets the TerminationGracePeriodSeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TerminationGracePeriodSeconds field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithTerminationGracePeriodSeconds(value int64) *AlertmanagerSpecApplyConfiguration {
	b.TerminationGracePeriodSeconds = &value
	return b
}

// WithHostUsers sets the HostUsers field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HostUsers field is set to the value of the last call.
func (b *AlertmanagerSpecApplyConfiguration) WithHostUsers(value bool) *AlertmanagerSpecApplyConfiguration {
	b.HostUsers = &value
	return b
}
