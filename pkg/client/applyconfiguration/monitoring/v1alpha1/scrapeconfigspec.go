// Copyright The prometheus-operator Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

import (
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	v1 "github.com/prometheus-operator/prometheus-operator/pkg/client/applyconfiguration/monitoring/v1"
	corev1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
)

// ScrapeConfigSpecApplyConfiguration represents a declarative configuration of the ScrapeConfigSpec type for use
// with apply.
//
// ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
type ScrapeConfigSpecApplyConfiguration struct {
	// jobName defines the value of the `job` label assigned to the scraped metrics by default.
	//
	// The `job_name` field in the rendered scrape configuration is always controlled by the
	// operator to prevent duplicate job names, which Prometheus does not allow. Instead the
	// `job` label is set by means of relabeling configs.
	JobName *string `json:"jobName,omitempty"`
	// staticConfigs defines a list of static targets with a common label set.
	StaticConfigs []StaticConfigApplyConfiguration `json:"staticConfigs,omitempty"`
	// fileSDConfigs defines a list of file service discovery configurations.
	FileSDConfigs []FileSDConfigApplyConfiguration `json:"fileSDConfigs,omitempty"`
	// httpSDConfigs defines a list of HTTP service discovery configurations.
	HTTPSDConfigs []HTTPSDConfigApplyConfiguration `json:"httpSDConfigs,omitempty"`
	// kubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
	KubernetesSDConfigs []KubernetesSDConfigApplyConfiguration `json:"kubernetesSDConfigs,omitempty"`
	// consulSDConfigs defines a list of Consul service discovery configurations.
	ConsulSDConfigs []ConsulSDConfigApplyConfiguration `json:"consulSDConfigs,omitempty"`
	// dnsSDConfigs defines a list of DNS service discovery configurations.
	DNSSDConfigs []DNSSDConfigApplyConfiguration `json:"dnsSDConfigs,omitempty"`
	// ec2SDConfigs defines a list of EC2 service discovery configurations.
	EC2SDConfigs []EC2SDConfigApplyConfiguration `json:"ec2SDConfigs,omitempty"`
	// azureSDConfigs defines a list of Azure service discovery configurations.
	AzureSDConfigs []AzureSDConfigApplyConfiguration `json:"azureSDConfigs,omitempty"`
	// gceSDConfigs defines a list of GCE service discovery configurations.
	GCESDConfigs []GCESDConfigApplyConfiguration `json:"gceSDConfigs,omitempty"`
	// openstackSDConfigs defines a list of OpenStack service discovery configurations.
	OpenStackSDConfigs []OpenStackSDConfigApplyConfiguration `json:"openstackSDConfigs,omitempty"`
	// digitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
	DigitalOceanSDConfigs []DigitalOceanSDConfigApplyConfiguration `json:"digitalOceanSDConfigs,omitempty"`
	// kumaSDConfigs defines a list of Kuma service discovery configurations.
	KumaSDConfigs []KumaSDConfigApplyConfiguration `json:"kumaSDConfigs,omitempty"`
	// eurekaSDConfigs defines a list of Eureka service discovery configurations.
	EurekaSDConfigs []EurekaSDConfigApplyConfiguration `json:"eurekaSDConfigs,omitempty"`
	// dockerSDConfigs defines a list of Docker service discovery configurations.
	DockerSDConfigs []DockerSDConfigApplyConfiguration `json:"dockerSDConfigs,omitempty"`
	// linodeSDConfigs defines a list of Linode service discovery configurations.
	LinodeSDConfigs []LinodeSDConfigApplyConfiguration `json:"linodeSDConfigs,omitempty"`
	// hetznerSDConfigs defines a list of Hetzner service discovery configurations.
	HetznerSDConfigs []HetznerSDConfigApplyConfiguration `json:"hetznerSDConfigs,omitempty"`
	// nomadSDConfigs defines a list of Nomad service discovery configurations.
	NomadSDConfigs []NomadSDConfigApplyConfiguration `json:"nomadSDConfigs,omitempty"`
	// dockerSwarmSDConfigs defines a list of Dockerswarm service discovery configurations.
	DockerSwarmSDConfigs []DockerSwarmSDConfigApplyConfiguration `json:"dockerSwarmSDConfigs,omitempty"`
	// puppetDBSDConfigs defines a list of PuppetDB service discovery configurations.
	PuppetDBSDConfigs []PuppetDBSDConfigApplyConfiguration `json:"puppetDBSDConfigs,omitempty"`
	// lightSailSDConfigs defines a list of Lightsail service discovery configurations.
	LightSailSDConfigs []LightSailSDConfigApplyConfiguration `json:"lightSailSDConfigs,omitempty"`
	// ovhcloudSDConfigs defines a list of OVHcloud service discovery configurations.
	OVHCloudSDConfigs []OVHCloudSDConfigApplyConfiguration `json:"ovhcloudSDConfigs,omitempty"`
	// scalewaySDConfigs defines a list of Scaleway instances and baremetal service discovery configurations.
	ScalewaySDConfigs []ScalewaySDConfigApplyConfiguration `json:"scalewaySDConfigs,omitempty"`
	// ionosSDConfigs defines a list of IONOS service discovery configurations.
	IonosSDConfigs []IonosSDConfigApplyConfiguration `json:"ionosSDConfigs,omitempty"`
	// relabelings defines how to rewrite the target's labels before scraping.
	// Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
	// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
	// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
	RelabelConfigs []v1.RelabelConfigApplyConfiguration `json:"relabelings,omitempty"`
	// metricsPath defines the HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
	MetricsPath *string `json:"metricsPath,omitempty"`
	// scrapeInterval defines the interval between consecutive scrapes.
	ScrapeInterval *monitoringv1.Duration `json:"scrapeInterval,omitempty"`
	// scrapeTimeout defines the number of seconds to wait until a scrape request times out.
	// The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
	ScrapeTimeout *monitoringv1.Duration `json:"scrapeTimeout,omitempty"`
	// scrapeProtocols defines the protocols to negotiate during a scrape. It tells clients the
	// protocols supported by Prometheus in order of preference (from most to least preferred).
	//
	// If unset, Prometheus uses its default value.
	//
	// It requires Prometheus >= v2.49.0.
	ScrapeProtocols []monitoringv1.ScrapeProtocol `json:"scrapeProtocols,omitempty"`
	// fallbackScrapeProtocol defines the protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
	//
	// It requires Prometheus >= v3.0.0.
	FallbackScrapeProtocol *monitoringv1.ScrapeProtocol `json:"fallbackScrapeProtocol,omitempty"`
	// honorTimestamps defines whether Prometheus preserves the timestamps
	// when exposed by the target.
	HonorTimestamps *bool `json:"honorTimestamps,omitempty"`
	// trackTimestampsStaleness defines whether Prometheus tracks staleness of
	// the metrics that have an explicit timestamp present in scraped data.
	// Has no effect if `honorTimestamps` is false.
	// It requires Prometheus >= v2.48.0.
	TrackTimestampsStaleness *bool `json:"trackTimestampsStaleness,omitempty"`
	// honorLabels defines when true the metric's labels when they collide
	// with the target's labels.
	HonorLabels *bool `json:"honorLabels,omitempty"`
	// params defines optional HTTP URL parameters
	Params map[string][]string `json:"params,omitempty"`
	// scheme defines the protocol scheme used for requests.
	Scheme *monitoringv1.Scheme `json:"scheme,omitempty"`
	// enableCompression when false, Prometheus will request uncompressed response from the scraped target.
	//
	// It requires Prometheus >= v2.49.0.
	//
	// If unset, Prometheus uses true by default.
	EnableCompression *bool `json:"enableCompression,omitempty"`
	// enableHTTP2 defines whether to enable HTTP2.
	EnableHTTP2 *bool `json:"enableHTTP2,omitempty"`
	// basicAuth defines information to use on every scrape request.
	BasicAuth *v1.BasicAuthApplyConfiguration `json:"basicAuth,omitempty"`
	// authorization defines the header to use on every scrape request.
	Authorization *v1.SafeAuthorizationApplyConfiguration `json:"authorization,omitempty"`
	// oauth2 defines the configuration to use on every scrape request.
	OAuth2 *v1.OAuth2ApplyConfiguration `json:"oauth2,omitempty"`
	// tlsConfig defines the TLS configuration to use on every scrape request
	TLSConfig *v1.SafeTLSConfigApplyConfiguration `json:"tlsConfig,omitempty"`
	// sampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
	SampleLimit *uint64 `json:"sampleLimit,omitempty"`
	// targetLimit defines a limit on the number of scraped targets that will be accepted.
	TargetLimit *uint64 `json:"targetLimit,omitempty"`
	// labelLimit defines the per-scrape limit on number of labels that will be accepted for a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	LabelLimit *uint64 `json:"labelLimit,omitempty"`
	// labelNameLengthLimit defines the per-scrape limit on length of labels name that will be accepted for a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	LabelNameLengthLimit *uint64 `json:"labelNameLengthLimit,omitempty"`
	// labelValueLengthLimit defines the per-scrape limit on length of labels value that will be accepted for a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	LabelValueLengthLimit                      *uint64 `json:"labelValueLengthLimit,omitempty"`
	v1.NativeHistogramConfigApplyConfiguration `json:",inline"`
	// keepDroppedTargets defines the per-scrape limit on the number of targets dropped by relabeling
	// that will be kept in memory. 0 means no limit.
	//
	// It requires Prometheus >= v2.47.0.
	KeepDroppedTargets *uint64 `json:"keepDroppedTargets,omitempty"`
	// metricRelabelings defines the metricRelabelings to apply to samples before ingestion.
	MetricRelabelConfigs []v1.RelabelConfigApplyConfiguration `json:"metricRelabelings,omitempty"`
	// ProxyConfig allows customizing the proxy behaviour for this scrape config.
	v1.ProxyConfigApplyConfiguration `json:",inline"`
	// nameValidationScheme defines the validation scheme for metric and label names.
	//
	// It requires Prometheus >= v3.0.0.
	NameValidationScheme *monitoringv1.NameValidationSchemeOptions `json:"nameValidationScheme,omitempty"`
	// nameEscapingScheme defines the metric name escaping mode to request through content negotiation.
	//
	// It requires Prometheus >= v3.4.0.
	NameEscapingScheme *monitoringv1.NameEscapingSchemeOptions `json:"nameEscapingScheme,omitempty"`
	// scrapeClass defines the scrape class to apply.
	ScrapeClassName *string `json:"scrapeClass,omitempty"`
}

// ScrapeConfigSpecApplyConfiguration constructs a declarative configuration of the ScrapeConfigSpec type for use with
// apply.
func ScrapeConfigSpec() *ScrapeConfigSpecApplyConfiguration {
	return &ScrapeConfigSpecApplyConfiguration{}
}

// WithJobName sets the JobName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the JobName field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithJobName(value string) *ScrapeConfigSpecApplyConfiguration {
	b.JobName = &value
	return b
}

// WithStaticConfigs adds the given value to the StaticConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the StaticConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithStaticConfigs(values ...*StaticConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithStaticConfigs")
		}
		b.StaticConfigs = append(b.StaticConfigs, *values[i])
	}
	return b
}

// WithFileSDConfigs adds the given value to the FileSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the FileSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithFileSDConfigs(values ...*FileSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithFileSDConfigs")
		}
		b.FileSDConfigs = append(b.FileSDConfigs, *values[i])
	}
	return b
}

// WithHTTPSDConfigs adds the given value to the HTTPSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the HTTPSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithHTTPSDConfigs(values ...*HTTPSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithHTTPSDConfigs")
		}
		b.HTTPSDConfigs = append(b.HTTPSDConfigs, *values[i])
	}
	return b
}

// WithKubernetesSDConfigs adds the given value to the KubernetesSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KubernetesSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithKubernetesSDConfigs(values ...*KubernetesSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithKubernetesSDConfigs")
		}
		b.KubernetesSDConfigs = append(b.KubernetesSDConfigs, *values[i])
	}
	return b
}

// WithConsulSDConfigs adds the given value to the ConsulSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ConsulSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithConsulSDConfigs(values ...*ConsulSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConsulSDConfigs")
		}
		b.ConsulSDConfigs = append(b.ConsulSDConfigs, *values[i])
	}
	return b
}

// WithDNSSDConfigs adds the given value to the DNSSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DNSSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithDNSSDConfigs(values ...*DNSSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithDNSSDConfigs")
		}
		b.DNSSDConfigs = append(b.DNSSDConfigs, *values[i])
	}
	return b
}

// WithEC2SDConfigs adds the given value to the EC2SDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the EC2SDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithEC2SDConfigs(values ...*EC2SDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithEC2SDConfigs")
		}
		b.EC2SDConfigs = append(b.EC2SDConfigs, *values[i])
	}
	return b
}

// WithAzureSDConfigs adds the given value to the AzureSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AzureSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithAzureSDConfigs(values ...*AzureSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAzureSDConfigs")
		}
		b.AzureSDConfigs = append(b.AzureSDConfigs, *values[i])
	}
	return b
}

// WithGCESDConfigs adds the given value to the GCESDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the GCESDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithGCESDConfigs(values ...*GCESDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithGCESDConfigs")
		}
		b.GCESDConfigs = append(b.GCESDConfigs, *values[i])
	}
	return b
}

// WithOpenStackSDConfigs adds the given value to the OpenStackSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the OpenStackSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithOpenStackSDConfigs(values ...*OpenStackSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithOpenStackSDConfigs")
		}
		b.OpenStackSDConfigs = append(b.OpenStackSDConfigs, *values[i])
	}
	return b
}

// WithDigitalOceanSDConfigs adds the given value to the DigitalOceanSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DigitalOceanSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithDigitalOceanSDConfigs(values ...*DigitalOceanSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithDigitalOceanSDConfigs")
		}
		b.DigitalOceanSDConfigs = append(b.DigitalOceanSDConfigs, *values[i])
	}
	return b
}

// WithKumaSDConfigs adds the given value to the KumaSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KumaSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithKumaSDConfigs(values ...*KumaSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithKumaSDConfigs")
		}
		b.KumaSDConfigs = append(b.KumaSDConfigs, *values[i])
	}
	return b
}

// WithEurekaSDConfigs adds the given value to the EurekaSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the EurekaSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithEurekaSDConfigs(values ...*EurekaSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithEurekaSDConfigs")
		}
		b.EurekaSDConfigs = append(b.EurekaSDConfigs, *values[i])
	}
	return b
}

// WithDockerSDConfigs adds the given value to the DockerSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DockerSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithDockerSDConfigs(values ...*DockerSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithDockerSDConfigs")
		}
		b.DockerSDConfigs = append(b.DockerSDConfigs, *values[i])
	}
	return b
}

// WithLinodeSDConfigs adds the given value to the LinodeSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the LinodeSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithLinodeSDConfigs(values ...*LinodeSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithLinodeSDConfigs")
		}
		b.LinodeSDConfigs = append(b.LinodeSDConfigs, *values[i])
	}
	return b
}

// WithHetznerSDConfigs adds the given value to the HetznerSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the HetznerSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithHetznerSDConfigs(values ...*HetznerSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithHetznerSDConfigs")
		}
		b.HetznerSDConfigs = append(b.HetznerSDConfigs, *values[i])
	}
	return b
}

// WithNomadSDConfigs adds the given value to the NomadSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the NomadSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithNomadSDConfigs(values ...*NomadSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithNomadSDConfigs")
		}
		b.NomadSDConfigs = append(b.NomadSDConfigs, *values[i])
	}
	return b
}

// WithDockerSwarmSDConfigs adds the given value to the DockerSwarmSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DockerSwarmSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithDockerSwarmSDConfigs(values ...*DockerSwarmSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithDockerSwarmSDConfigs")
		}
		b.DockerSwarmSDConfigs = append(b.DockerSwarmSDConfigs, *values[i])
	}
	return b
}

// WithPuppetDBSDConfigs adds the given value to the PuppetDBSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the PuppetDBSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithPuppetDBSDConfigs(values ...*PuppetDBSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithPuppetDBSDConfigs")
		}
		b.PuppetDBSDConfigs = append(b.PuppetDBSDConfigs, *values[i])
	}
	return b
}

// WithLightSailSDConfigs adds the given value to the LightSailSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the LightSailSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithLightSailSDConfigs(values ...*LightSailSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithLightSailSDConfigs")
		}
		b.LightSailSDConfigs = append(b.LightSailSDConfigs, *values[i])
	}
	return b
}

// WithOVHCloudSDConfigs adds the given value to the OVHCloudSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the OVHCloudSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithOVHCloudSDConfigs(values ...*OVHCloudSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithOVHCloudSDConfigs")
		}
		b.OVHCloudSDConfigs = append(b.OVHCloudSDConfigs, *values[i])
	}
	return b
}

// WithScalewaySDConfigs adds the given value to the ScalewaySDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ScalewaySDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithScalewaySDConfigs(values ...*ScalewaySDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithScalewaySDConfigs")
		}
		b.ScalewaySDConfigs = append(b.ScalewaySDConfigs, *values[i])
	}
	return b
}

// WithIonosSDConfigs adds the given value to the IonosSDConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the IonosSDConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithIonosSDConfigs(values ...*IonosSDConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithIonosSDConfigs")
		}
		b.IonosSDConfigs = append(b.IonosSDConfigs, *values[i])
	}
	return b
}

// WithRelabelConfigs adds the given value to the RelabelConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RelabelConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithRelabelConfigs(values ...*v1.RelabelConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithRelabelConfigs")
		}
		b.RelabelConfigs = append(b.RelabelConfigs, *values[i])
	}
	return b
}

// WithMetricsPath sets the MetricsPath field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MetricsPath field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithMetricsPath(value string) *ScrapeConfigSpecApplyConfiguration {
	b.MetricsPath = &value
	return b
}

// WithScrapeInterval sets the ScrapeInterval field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScrapeInterval field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeInterval(value monitoringv1.Duration) *ScrapeConfigSpecApplyConfiguration {
	b.ScrapeInterval = &value
	return b
}

// WithScrapeTimeout sets the ScrapeTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScrapeTimeout field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeTimeout(value monitoringv1.Duration) *ScrapeConfigSpecApplyConfiguration {
	b.ScrapeTimeout = &value
	return b
}

// WithScrapeProtocols adds the given value to the ScrapeProtocols field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ScrapeProtocols field.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeProtocols(values ...monitoringv1.ScrapeProtocol) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		b.ScrapeProtocols = append(b.ScrapeProtocols, values[i])
	}
	return b
}

// WithFallbackScrapeProtocol sets the FallbackScrapeProtocol field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FallbackScrapeProtocol field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithFallbackScrapeProtocol(value monitoringv1.ScrapeProtocol) *ScrapeConfigSpecApplyConfiguration {
	b.FallbackScrapeProtocol = &value
	return b
}

// WithHonorTimestamps sets the HonorTimestamps field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HonorTimestamps field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithHonorTimestamps(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.HonorTimestamps = &value
	return b
}

// WithTrackTimestampsStaleness sets the TrackTimestampsStaleness field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TrackTimestampsStaleness field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithTrackTimestampsStaleness(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.TrackTimestampsStaleness = &value
	return b
}

// WithHonorLabels sets the HonorLabels field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HonorLabels field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithHonorLabels(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.HonorLabels = &value
	return b
}

// WithParams puts the entries into the Params field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Params field,
// overwriting an existing map entries in Params field with the same key.
func (b *ScrapeConfigSpecApplyConfiguration) WithParams(entries map[string][]string) *ScrapeConfigSpecApplyConfiguration {
	if b.Params == nil && len(entries) > 0 {
		b.Params = make(map[string][]string, len(entries))
	}
	for k, v := range entries {
		b.Params[k] = v
	}
	return b
}

// WithScheme sets the Scheme field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Scheme field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScheme(value monitoringv1.Scheme) *ScrapeConfigSpecApplyConfiguration {
	b.Scheme = &value
	return b
}

// WithEnableCompression sets the EnableCompression field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the EnableCompression field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithEnableCompression(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.EnableCompression = &value
	return b
}

// WithEnableHTTP2 sets the EnableHTTP2 field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the EnableHTTP2 field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithEnableHTTP2(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.EnableHTTP2 = &value
	return b
}

// WithBasicAuth sets the BasicAuth field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the BasicAuth field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithBasicAuth(value *v1.BasicAuthApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	b.BasicAuth = value
	return b
}

// WithAuthorization sets the Authorization field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Authorization field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithAuthorization(value *v1.SafeAuthorizationApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	b.Authorization = value
	return b
}

// WithOAuth2 sets the OAuth2 field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the OAuth2 field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithOAuth2(value *v1.OAuth2ApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	b.OAuth2 = value
	return b
}

// WithTLSConfig sets the TLSConfig field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TLSConfig field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithTLSConfig(value *v1.SafeTLSConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	b.TLSConfig = value
	return b
}

// WithSampleLimit sets the SampleLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SampleLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithSampleLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.SampleLimit = &value
	return b
}

// WithTargetLimit sets the TargetLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TargetLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithTargetLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.TargetLimit = &value
	return b
}

// WithLabelLimit sets the LabelLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LabelLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithLabelLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.LabelLimit = &value
	return b
}

// WithLabelNameLengthLimit sets the LabelNameLengthLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LabelNameLengthLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithLabelNameLengthLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.LabelNameLengthLimit = &value
	return b
}

// WithLabelValueLengthLimit sets the LabelValueLengthLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LabelValueLengthLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithLabelValueLengthLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.LabelValueLengthLimit = &value
	return b
}

// WithScrapeNativeHistograms sets the ScrapeNativeHistograms field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScrapeNativeHistograms field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeNativeHistograms(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.NativeHistogramConfigApplyConfiguration.ScrapeNativeHistograms = &value
	return b
}

// WithScrapeClassicHistograms sets the ScrapeClassicHistograms field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScrapeClassicHistograms field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeClassicHistograms(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.NativeHistogramConfigApplyConfiguration.ScrapeClassicHistograms = &value
	return b
}

// WithNativeHistogramBucketLimit sets the NativeHistogramBucketLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NativeHistogramBucketLimit field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithNativeHistogramBucketLimit(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.NativeHistogramConfigApplyConfiguration.NativeHistogramBucketLimit = &value
	return b
}

// WithNativeHistogramMinBucketFactor sets the NativeHistogramMinBucketFactor field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NativeHistogramMinBucketFactor field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithNativeHistogramMinBucketFactor(value resource.Quantity) *ScrapeConfigSpecApplyConfiguration {
	b.NativeHistogramConfigApplyConfiguration.NativeHistogramMinBucketFactor = &value
	return b
}

// WithConvertClassicHistogramsToNHCB sets the ConvertClassicHistogramsToNHCB field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ConvertClassicHistogramsToNHCB field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithConvertClassicHistogramsToNHCB(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.NativeHistogramConfigApplyConfiguration.ConvertClassicHistogramsToNHCB = &value
	return b
}

// WithKeepDroppedTargets sets the KeepDroppedTargets field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KeepDroppedTargets field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithKeepDroppedTargets(value uint64) *ScrapeConfigSpecApplyConfiguration {
	b.KeepDroppedTargets = &value
	return b
}

// WithMetricRelabelConfigs adds the given value to the MetricRelabelConfigs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the MetricRelabelConfigs field.
func (b *ScrapeConfigSpecApplyConfiguration) WithMetricRelabelConfigs(values ...*v1.RelabelConfigApplyConfiguration) *ScrapeConfigSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithMetricRelabelConfigs")
		}
		b.MetricRelabelConfigs = append(b.MetricRelabelConfigs, *values[i])
	}
	return b
}

// WithProxyURL sets the ProxyURL field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyURL field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithProxyURL(value string) *ScrapeConfigSpecApplyConfiguration {
	b.ProxyConfigApplyConfiguration.ProxyURL = &value
	return b
}

// WithNoProxy sets the NoProxy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NoProxy field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithNoProxy(value string) *ScrapeConfigSpecApplyConfiguration {
	b.ProxyConfigApplyConfiguration.NoProxy = &value
	return b
}

// WithProxyFromEnvironment sets the ProxyFromEnvironment field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyFromEnvironment field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithProxyFromEnvironment(value bool) *ScrapeConfigSpecApplyConfiguration {
	b.ProxyConfigApplyConfiguration.ProxyFromEnvironment = &value
	return b
}

// WithProxyConnectHeader puts the entries into the ProxyConnectHeader field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the ProxyConnectHeader field,
// overwriting an existing map entries in ProxyConnectHeader field with the same key.
func (b *ScrapeConfigSpecApplyConfiguration) WithProxyConnectHeader(entries map[string][]corev1.SecretKeySelector) *ScrapeConfigSpecApplyConfiguration {
	if b.ProxyConfigApplyConfiguration.ProxyConnectHeader == nil && len(entries) > 0 {
		b.ProxyConfigApplyConfiguration.ProxyConnectHeader = make(map[string][]corev1.SecretKeySelector, len(entries))
	}
	for k, v := range entries {
		b.ProxyConfigApplyConfiguration.ProxyConnectHeader[k] = v
	}
	return b
}

// WithNameValidationScheme sets the NameValidationScheme field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NameValidationScheme field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithNameValidationScheme(value monitoringv1.NameValidationSchemeOptions) *ScrapeConfigSpecApplyConfiguration {
	b.NameValidationScheme = &value
	return b
}

// WithNameEscapingScheme sets the NameEscapingScheme field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NameEscapingScheme field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithNameEscapingScheme(value monitoringv1.NameEscapingSchemeOptions) *ScrapeConfigSpecApplyConfiguration {
	b.NameEscapingScheme = &value
	return b
}

// WithScrapeClassName sets the ScrapeClassName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScrapeClassName field is set to the value of the last call.
func (b *ScrapeConfigSpecApplyConfiguration) WithScrapeClassName(value string) *ScrapeConfigSpecApplyConfiguration {
	b.ScrapeClassName = &value
	return b
}
